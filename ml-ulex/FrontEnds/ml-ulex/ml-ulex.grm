%defs (
  structure LS = LexSpec
  structure AMap = AtomMap

  structure S = LexSpec

  structure RE = RegExp
  structure SIS = RE.SymSet

  fun listToASet ls = AtomSet.addList (AtomSet.empty, ls)

  val wildcard = RE.mkSymSet (SIS.complement (SIS.singleton 0w10)) (* all but \n *)
  fun charToSym c = Word32.fromInt (Char.ord c)

  fun flip (x, y) = (y, x)
);

%tokens
  : BAR		("|")
  | DOT		(".")
  | DOLLAR	("$")
  | PLUS	("+")
  | STAR	("*")
  | QUERY	("?")
  | SEMI	(";")
  | LP		("(")	| RP	(")")
  | LSB		("[")	| RSB	("]")
  | LCB		("{")	| RCB	("}")
  | LT		("<")	| GT	(">")
  | SLASH	("/")
  | COMMA	(",")
  | CARAT	("^")
  | DASH	("-")
  | DARROW	("=>")
  | EQ		("=")
  | KW_defs	("%defs")
  | KW_name	("%name")
  | KW_states	("%states")
  | KW_let	("%let")
  | KW_charset	("%charset")
  | UNICODE	("unicode")
  | ASCII7	("ascii7")
  | ASCII8	("ascii8")
  | STRING of string
  | CHAR of char
  | ID of string
  | CODE of string
  | BOGUS
  ;

file
  : decls@(LS.mkSpec(), AMap.empty)
  ;

decls(spec, env)
  : decl@(spec, env) ";" decls@(decl)
      => (decls)
  | 
      => (spec)
  ;

decl(spec, env)
  : directive@(LS.getConf spec, env)
      => (let val (conf', env') = directive
	  in 
	    (LS.updConf (spec, conf'),
	     env')
	  end)
  | "%defs" CODE
      => (LS.updDecls (spec, CODE), env)
  | rule@(env)
      => (LS.addRule (spec, rule), env)
  ;

directive(conf, env)
  : "%let" ID "=" re@(env)
      => (conf, AMap.insert (env, Atom.atom ID, re))
  | "%states" (ID ","? => (ID))+
      => (LS.updStartStates (conf, listToASet (map Atom.atom SR1)), 
	  env)
  | "%charset"
      ( UNICODE => (LS.updClamp (conf, LS.NO_CLAMP), env)
      | ASCII7 =>  (LS.updClamp (conf, LS.CLAMP127), env)
      | ASCII8 =>  (LS.updClamp (conf, LS.CLAMP255), env))
  | "%name" ID
      => (LS.updStructName (conf, ID), env)
  ;

rule(env)
  : ("<" (ID ","? => (ID))+ ">")? re@(env) "=>" CODE
      => ((Option.map (listToASet o (map Atom.atom)) SR1, re), CODE)
  ;

re(env)
  : or_re@(env)
  ;

or_re(env)
  : cat_re@(env) ("|" cat_re@(env))*
      => (foldl (RE.mkOr o flip) cat_re SR1)
  ;

cat_re(env)
  : post_re@(env) (post_re@(env))*
      => (foldl (RE.mkConcat o flip) post_re SR1)
  ;

post_re(env)
  : prim_re@(env) 
      ( "?" => (RE.mkOpt)
      | "*" => (RE.mkClosure)
      | "+" => (fn re => RE.mkAtLeast (re, 1))
      | => (fn x => x)
      )
      => (SR1 prim_re)
  ;

prim_re(env)
  : ID
      => (valOf (AMap.find (env, Atom.atom ID)))
  | STRING
      => ( foldr RE.mkConcat
		 RE.epsilon 
		 (map (RE.mkSym o charToSym) (String.explode STRING)) )
  | "(" re@(env) ")"
  | char
      => (RE.mkSym char)
  | "."
      => (wildcard)
  | "[" 
        ( "^" => (SIS.complement) 
        | => (fn x => x)
        )

        ( char "-" char => (SIS.interval (char1, char2))
        | char => (SIS.singleton char)
        )+
    "]"
      => (RE.mkSymSet (SR1 (foldl SIS.union (hd SR2) (tl SR2))))
  ;

char
  : CHAR
      => (charToSym CHAR)
  ;
