%defs (
  structure LS = LexSpec
  structure AMap = AtomMap

  structure S = LexSpec

  structure RE = RegExp
  structure SIS = RE.SymSet

  fun listToASet ls = AtomSet.addList (AtomSet.empty, ls)
  fun charToSym c = Word32.fromInt (Char.ord c)

  fun flip (x, y) = (y, x)

  type antlr_annotation = (Lex.pos * Lex.pos) * string

);

%tokens
  : BAR		("|")
  | AMP		("&")
  | DOT		(".")
  | DOLLAR	("$")
  | PLUS	("+")
  | STAR	("*")
  | QUERY	("?")
  | SEMI	(";")
  | LP		("(")	| RP	(")")
  | LSB		("[")	| RSB	("]")
  | LCB		("{")	| RCB	("}")
  | LT		("<")	| GT	(">")
  | SLASH	("/")
  | COMMA	(",")
  | CARAT	("^")
  | DASH	("-")
  | DARROW	("=>")
  | EQ		("=")
  | KW_defs	("%defs")
  | KW_name	("%name")
  | KW_states	("%states")
  | KW_let	("%let")
  | KW_charset	("%charset")
  | UTF8	("utf8")
  | ASCII7	("ascii7")
  | ASCII8	("ascii8")
  | REPEAT of int
  | CHAR of char
  | UCHAR of Word32.word
  | ID of string
  | CODE of string
  | BOGUS
  ;

%keywords
  "%defs", "%name", "%states", "%let", "%charset" ;

file
  : decls@(LS.mkSpec(), AMap.empty)
  ;

decls(spec, env)
  : decl@(spec, env) ";" decls@(decl)
      => (decls)
  | 
      => (spec)
  ;

decl(spec, env)
  : directive@(LS.getConf spec, env)
      => (let val (conf', env') = directive
	  in 
	    (LS.updConf (spec, conf'),
	     env')
	  end)
  | "%defs" CODE
      => (LS.updDecls (spec, CODE), env)
  | rule@(env)
      => (LS.addRule (spec, rule), env)
  ;

directive(conf, env)
  : "%let" ID "=" re@(env)
      => (conf, AMap.insert (env, Atom.atom ID, re))
  | "%states" (ID ","? => (ID))+
      => (LS.updStartStates (conf, listToASet (map Atom.atom SR)), 
	  env)
  | "%charset"
      ( "utf8" => (LS.updClamp (conf, LS.NO_CLAMP), env)
      | "ascii7" =>  (LS.updClamp (conf, LS.CLAMP127), env)
      | "ascii8" =>  (LS.updClamp (conf, LS.CLAMP255), env))
  | "%name" ID
      => (LS.updStructName (conf, ID), env)
  ;

rule(env)
  : ("<" (ID ","? => (ID))+ ">")? re@(env) "=>" CODE
      => ((Option.map (listToASet o (map Atom.atom)) SR, re), CODE)
  ;

re(env)
  : or_re@(env)
  ;

or_re(env)
  : and_re@(env) ("|" and_re@(env))*
      => (foldl (RE.mkOr o flip) and_re SR)
  ;

and_re(env)
  : not_re@(env) ("&" not_re@(env))*
      => (foldl (RE.mkAnd o flip) not_re SR)
  ;

not_re(env)
  : "^" cat_re@(env)
      => (RE.mkNot cat_re)
  | cat_re@(env)
  ;

cat_re(env)
  : post_re@(env) (post_re@(env))*
      => (foldl (RE.mkConcat o flip) post_re SR)
  ;

post_re(env)
  : prim_re@(env) 
      ( "?" => (RE.mkOpt)
      | "*" => (RE.mkClosure)
      | "+" => (fn re => RE.mkAtLeast (re, 1))
      | REPEAT => (fn re => RE.mkRep (re, REPEAT, REPEAT))
      | => (fn x => x)
      )
      => (SR prim_re)
  ;

prim_re(env)
  : ID
      => (case (AMap.find (env, Atom.atom ID))
	   of SOME re => re
	    | NONE => (addAnnotation (ID_SPAN, String.concat [
		"Error: {", ID, "} is undefined."]);
		RE.any))
  | "(" re@(env) ")"
  | char
      => (RE.mkSym char)
  | "."
      => (RE.any)
  | "[" 
        ( "^" => (SIS.complement) 
        | => (fn x => x)
        )

        ( char "-" char => 
	    (if char1 <= char2 then
	       SIS.interval (char1, char2)
	     else (addAnnotation (FULL_SPAN, String.concat [
	       "Error: malformed character class: ",
	       Word32.toString char1, " - ",
	       Word32.toString char2, "."]);
	       SIS.universe))
        | char => (SIS.singleton char)
        )+
    "]"
      => (RE.mkSymSet (SR1 (foldl SIS.union (hd SR2) (tl SR2))))
  ;

char
  : CHAR
      => (charToSym CHAR)
  | UCHAR
  ;
