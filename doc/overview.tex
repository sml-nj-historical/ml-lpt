\chapter{Overview}\label{chap:overview}

In software, language recognition is ubiquitous: nearly every program deals at some level with structured input given in textual form.  The simplest recognition problems can be solved directly, but as the complexity of the language grows, recognition and processing becomes more difficult.  

Although sophisticated language processing is sometimes done by hand, the use of scanner and parser generators\footnote{
  ``Scanner generator'' and ``parser generator'' will often be shortened to ``scanner'' and ``parser'' respectively.  This is justified by viewing a parser generator as a parameterized parser.
} is much more common.  The {\sc Unix} tools {\sc lex} and {\sc yacc} are the archetypical examples of such generators.  Tradition has it that when a new programming language is introduced, new scanner and parser generators are written in that language, and generate code for that language.  Traditional \emph{also} has it that the new tools are modeled after the old {\sc lex} and {\sc yacc} tools, both in terms of the algorithms used, and often the syntax as well.  The language {\sc Standard ML} is no exception: {\sc ml-lex} and {\sc ml-yacc} are the {\sc SML} incarnations of the old {\sc Unix} tools.

This manual describes two new tools, {\sc ml-ulex} and {\sc ml-antlr}, that follow tradition in separating scanning from parsing, but break from tradition in their implementation: {\sc ml-ulex} is based on \emph{regular expression derivatives} rather than subset-construction, and {\sc ml-antlr} is based on $LL(k)$ parsing rather than $LALR(1)$ parsing.   
%Importantly, the new implementations are by no means equivalent to the standard implementations

\section{Motivation}






%Traditionally, sophisticated language recognition is performed in a two-phase process.  The first phase, \emph{lexical analysis}, separates the input text into tokens (or \emph{lexemes})

%Early on, 

%Traditionally, language recognition falls into two classes: \emph{scanning} (also called lexing), which can recognize regular languages, and \emph{parsers}

%Language recognition garnered much attention in the early days of computer science

%Two classes of languages---\emph{regular} and \emph{context-free}---emerged as having the most practical significance, in part because 

%; both the theory and practice of language recognition has long been considered settled.  

%, with \emph{regular} and \emph{context-free} languages emerging 

%The theory of language recognition has been extensively studied.  Of the classes of languages that have been studied, two in particular form the conceptual basis for most practical language recognition: the .