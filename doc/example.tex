%!TEX root = manual.tex
%
\chapter{A complete example}
\label{ch:example}

This chapter gives a complete example of a simple calculator
language implemented using both \texttt{ml-ulex} and \texttt{ml-antlr}.
Figure~\ref{fig:calc-sources} gives the CM file for the project.
Note that we are assuming that the \texttt{ml-ulex} and \texttt{ml-antlr}
tools have been run by hand.
\begin{figure}[h]
\begin{verbatim}

Library

  structure CalcLex
  functor CalcParse
  structure CalcTest

is
  $/basis.cm
  $/smlnj-lib.cm
  $/ml-lpt-lib.cm

  calc.grm.sml
  calc.lex.sml
  calc-test.sml

\end{verbatim}
\caption{The CM file: {\tt sources.cm}}
\label{fig:calc-sources}
\end{figure}

\begin{figure}

\begin{verbatim}
%name CalcLexer;

%let digit = [0-9];
%let int = {digit}+;
%let alpha = [a-zA-Z];
%let id = {alpha}({alpha} | {digit})*;

%defs (
  open CalcTokens
  type lex_result = token
  fun eof() = EOF
);

let     => ( T.KW_let );
in      => ( T.KW_in );
{id}    => ( T.ID (yytext) );
{int}   => ( T.NUM (valOf (Int.fromString (yytext))) );
"="     => ( T.EQ );
"+"     => ( T.PLUS );
"-"     => ( T.MINUS );
"*"     => ( T.TIMES );
"("     => ( T.LP );
")"     => ( T.RP );
" " | \n | \t
        => ( continue() );
.       => ( (* handle error *) );
\end{verbatim}
\caption{The ml-ulex specification: {\tt calc.lex}}
\label{fig:calc-lex}
\end{figure}

\begin{figure}[p]
\begin{verbatim}
%name Calc;

%tokens
  : KW_let  ("let")  | KW_in   ("in")
  | ID of string     | NUM of Int.int
  | EQ      ("=")    | PLUS    ("+")
  | TIMES   ("*")    | MINUS   ("-")
  | LP      ("(")    | RP      (")")
  ;
  
exp(env)
  : "let" ID "=" exp@(env) 
    "in" exp@(AtomMap.insert(env, Atom.atom ID, exp1))
      => ( exp2 )
  | addExp@(env)
  ;
  
addExp(env)
  : multExp@(env) ("+" multExp@(env))*
      => ( List.foldr op+ 0 multExp::SR )
  ;
  
multExp(env)
  : prefixExp@(env) ("*" prefixExp@(env))*
      => ( List.foldr op* 1 prefixExp::SR )
  ;
  
prefixExp(env)
  : atomicExp@(env)
  | "-" prefixExp@(env)
      => ( ~prefixExp )
  ;
  
atomicExp(env)
  : ID  
      => ( valOf(AtomMap.find (env, Atom.atom ID)) )
  | NUM
  | "(" exp@(env) ")"
  ;
\end{verbatim}
\caption{The ml-antlr specification: {\tt calc.grm}}
\label{fig:calc-grm}
\end{figure}

\begin{figure}
\begin{verbatim}
structure CalcTest =
  struct

    structure CP = CalcParseFn(CalcLexer)

  (* val calc : TextIO.instream -> Int.int *)
    fun calc instrm = let
      val sm = StreamPos.mkSourcemap()
      val lex = CalcLexer.lex sm
      val strm = CalcLexer.streamifyInstream instrm
      val (r, strm', errs) = CP.parse lex AtomMap.empty strm
    in
      print (String.concatWith "\n" 
            (map (Repair.repairToString CalcTokens.toString sm) errs));
      r
    end

  end
\end{verbatim}
\caption{The driver: {\tt calc-test.sml}}
\label{fig:calc-test}
\end{figure}